"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const change_case_1 = require("change-case");
const lodash_1 = require("lodash");
/**
 * Remove starting and ending double or single quotes.
 * Only removes if these quotes are of the same type,
 * and at the start and end of the text.
 * @param text the text to remove the quotes from
 */
function unquote(text) {
    if (!text)
        return '';
    if (text.startsWith('"') && text.endsWith('"')) {
        return text.substring(1, text.length - 1);
    }
    if (text.startsWith("'") && text.endsWith("'")) {
        return text.substring(1, text.length - 1);
    }
    return text;
}
exports.unquote = unquote;
/**
 * Escapes only the quotation marks in the string.
 * For example: "That's right" becomes "That\'s right"
 * @param text the text to escape the quotation marks
 */
function escapeQuotes(text) {
    return text.replace("'", "\\\'").replace('"', '\\\"');
}
exports.escapeQuotes = escapeQuotes;
/**
 * Join multiple lines of text with newlines.
 * Filters out the nulls
 * @param lines
 */
function multiline(...lines) {
    return lines.filter(line => !!line).join('\n');
}
exports.multiline = multiline;
/**
 * Create a deep clone of the object by converting it
 * to JSON and back to an object. Only works with data objects.
 * Note: can be slow, so only use when necessary.
 * @param object the object to clone
 */
function clone(object) {
    return JSON.parse(JSON.stringify(object));
}
exports.clone = clone;
/**
 * Perform a deep merge, including the merging of arrays.
 * By default lodash.merge does not merge arrays.
 * @param object the original object
 * @param other the object to merge with
 * @returns the merged object
 */
function merge(object, other) {
    function customizer(objValue, srcValue) {
        if (lodash_1.isArray(objValue)) {
            return objValue.concat(srcValue);
        }
    }
    return lodash_1.mergeWith(object, other, customizer);
}
exports.merge = merge;
/** Find a parameter of the given name in the widget */
function findParam(widget, name, includeResolved) {
    if (!widget.params)
        return null;
    return widget.params.find(param => param.name == name && (includeResolved || !param.resolved));
}
exports.findParam = findParam;
/** Find and remove a parameter in the widget */
function findAndRemoveParam(widget, name, options = { includeExpressions: true, includeResolved: false }) {
    if (!widget.params)
        return null;
    function filter(param) {
        if (param.name != name)
            return false;
        if (!options.includeResolved && param.resolved)
            return false;
        if (!options.includeExpressions && param.type == 'expression')
            return false;
        return true;
    }
    const param = widget.params.find(filter);
    if (param)
        lodash_1.pull(widget.params, param);
    return param;
}
exports.findAndRemoveParam = findAndRemoveParam;
function isThemeStyle(style) {
    return style.startsWith('theme');
}
exports.isThemeStyle = isThemeStyle;
function parsePropertyStyle(enumName, styleParam) {
    if (styleParam.type == 'expression') {
        return styleParam.value.toString();
    }
    else {
        return `${enumName}.${change_case_1.camelCase(unquote(styleParam.value.toString()))}`;
    }
}
exports.parsePropertyStyle = parsePropertyStyle;
function parseStyleString(styleParam) {
    if (styleParam.type == 'expression') {
        return styleParam.value.toString();
    }
    else {
        return `"${unquote(styleParam.value.toString())}"`;
    }
}
exports.parseStyleString = parseStyleString;
function parseThemeStyle(style) {
    let selector;
    if (!isThemeStyle(style))
        return null;
    if (unquote(style) == style) {
        const themeRegExp = /theme\(([\w\-\/]+)\)/g;
        const match = themeRegExp.exec(style);
        if (!match)
            return null;
        const escaped = match[1].replace(/\//g, 'xxx');
        const cased = change_case_1.camelCase(escaped);
        selector = cased.replace(/xxx/g, '.');
    }
    else {
        selector = unquote(style);
    }
    return `Theme.of(context).${selector}`;
}
exports.parseThemeStyle = parseThemeStyle;
function parseStyleColor(color) {
    if (!color)
        return '';
    const themeStyle = parseThemeStyle(color);
    if (themeStyle)
        return themeStyle;
    if (color.length == 4 && color.startsWith('#') && color) {
        // #xyz => 0xFFxxyyzz
        const c = color.toUpperCase();
        return `Color(0xFF${c.charAt(1)}${c.charAt(1)}${c.charAt(2)}${c.charAt(2)}${c.charAt(3)}${c.charAt(3)})`; // Color(0xFFB74093)
    }
    if (color.length == 5 && color.startsWith('#') && color) {
        // #xyzO => 0xOOxxyyzz
        const c = color.toUpperCase();
        return `Color(0x${c.charAt(4)}${c.charAt(4)}${c.charAt(1)}${c.charAt(1)}${c.charAt(2)}${c.charAt(2)}${c.charAt(3)}${c.charAt(3)})`; // Color(0xFFB74093)
    }
    if (color.length == 7 && color.startsWith('#') && color) {
        // #abcdef => 0xFFabcdef
        return `Color(0xFF${color.substring(1, 7).toUpperCase()})`; // Color(0xFFB74093)
    }
    if (color.length == 9 && color.startsWith('#') && color) {
        // #abcdefop => 0xopabcdef
        return `Color(0x${color.substring(3, 9).toUpperCase()}${color.substring(1, 2).toUpperCase()})`;
    }
    const shadeRegExp = /(\w+)\[(\d{3})\]/g;
    const match = shadeRegExp.exec(color);
    if (match) {
        const flutterColor = match[1];
        const flutterShade = match[2];
        return `Colors.${change_case_1.camelCase(flutterColor)}.shade${flutterShade}`;
    }
    if (color.indexOf('.') < 0 && color.indexOf('(') < 0) {
        return `Colors.${change_case_1.camelCase(color)}`;
    }
    return color;
}
exports.parseStyleColor = parseStyleColor;
function parseStyleRepeat(repeatParam) {
    if (!repeatParam)
        return '';
    const repeat = repeatParam.value.toString();
    if (repeatParam.type == 'expression')
        return repeat;
    if (repeat.indexOf('.') < 0 && repeat.indexOf('(') < 0) {
        return `ImageRepeat.${change_case_1.camelCase(repeat)}`;
    }
    return repeat;
}
exports.parseStyleRepeat = parseStyleRepeat;
function parseStyleBackgroundSize(sizeParam) {
    // CSS:     https://www.w3schools.com/cssref/css3_pr_background-size.asp
    // Flutter: https://docs.flutter.io/flutter/painting/BoxFit-class.html
    if (!sizeParam)
        return '';
    const size = sizeParam.value.toString();
    if (sizeParam.type == 'expression')
        return size;
    if (size.indexOf('.') < 0 && size.indexOf('(') < 0) {
        return `BoxFit.${change_case_1.camelCase(size)}`;
    }
    return size;
}
exports.parseStyleBackgroundSize = parseStyleBackgroundSize;
function parseStyleMainAxisAlignment(alignmentParam) {
    // Flutter: https://docs.flutter.io/flutter/rendering/MainAxisAlignment-class.html
    if (!alignmentParam)
        return '';
    const alignment = alignmentParam.value.toString();
    if (alignmentParam.type == 'expression')
        return alignment;
    if (alignment.indexOf('.') < 0 && alignment.indexOf('(') < 0) {
        return `MainAxisAlignment.${change_case_1.camelCase(alignment)}`;
    }
    return alignment;
}
exports.parseStyleMainAxisAlignment = parseStyleMainAxisAlignment;
function parseStyleCrossAxisAlignment(alignmentParam) {
    // Flutter: https://docs.flutter.io/flutter/rendering/CrossAxisAlignment-class.html
    if (!alignmentParam)
        return '';
    const alignment = alignmentParam.value.toString();
    if (alignmentParam.type == 'expression')
        return alignment;
    if (alignment.indexOf('.') < 0 && alignment.indexOf('(') < 0) {
        return `CrossAxisAlignment.${change_case_1.camelCase(alignment)}`;
    }
    return alignment;
}
exports.parseStyleCrossAxisAlignment = parseStyleCrossAxisAlignment;
function parseStyleMainAxisSize(alignmentParam) {
    // Flutter: https://docs.flutter.io/flutter/rendering/MainAxisSize-class.html
    if (!alignmentParam)
        return '';
    const alignment = alignmentParam.value.toString();
    if (alignmentParam.type == 'expression')
        return alignment;
    if (alignment.indexOf('.') < 0 && alignment.indexOf('(') < 0) {
        return `MainAxisSize.${change_case_1.camelCase(alignment)}`;
    }
    return alignment;
}
exports.parseStyleMainAxisSize = parseStyleMainAxisSize;
function parseStyleCrossAxisSize(alignmentParam) {
    // Flutter: https://docs.flutter.io/flutter/rendering/CrossAxisSize-class.html
    if (!alignmentParam)
        return '';
    const alignment = alignmentParam.value.toString();
    if (alignmentParam.type == 'expression')
        return alignment;
    if (alignment.indexOf('.') < 0 && alignment.indexOf('(') < 0) {
        return `CrossAxisSize.${change_case_1.camelCase(alignment)}`;
    }
    return alignment;
}
exports.parseStyleCrossAxisSize = parseStyleCrossAxisSize;
function parseTRBLStyle(style) {
    const regexp = /[.a-z0-9\-\_\*\:\.\,\(\)\[\]]+/gi;
    const matches = style.match(regexp);
    switch (matches.length) {
        case 1: return {
            top: matches[0],
            right: matches[0],
            bottom: matches[0],
            left: matches[0]
        };
        case 2: return {
            top: matches[0],
            bottom: matches[0],
            left: matches[1],
            right: matches[1]
        };
        case 3: return {
            top: matches[0],
            right: matches[1],
            bottom: matches[2]
        };
        case 4: return {
            top: matches[0],
            right: matches[1],
            bottom: matches[2],
            left: matches[3]
        };
        default: return {};
    }
}
exports.parseTRBLStyle = parseTRBLStyle;
function parseBorderStyle(border) {
    const regexp = /[.a-z0-9\#\-\.\,\(\)\[\]]+/gi;
    const matches = border.match(regexp);
    switch (matches.length) {
        case 1: {
            if (matches[0] == 'none') {
                return { style: 'none' };
            }
            else if (parseFloat(matches[0])) {
                // border: 5.0
                return { width: parseStyleDoubleValue(matches[0]) };
            }
            else {
                // border: red
                return { color: parseStyleColor(matches[0]) };
            }
        }
        case 2: {
            if (parseFloat(matches[0])) {
                // border: 5.0 red
                return {
                    width: parseStyleDoubleValue(matches[0]),
                    color: parseStyleColor(matches[1])
                };
            }
            else {
                // border: solid red
                return {
                    style: matches[0],
                    color: parseStyleColor(matches[1])
                };
            }
        }
        case 3: return {
            // border: 5.0 solid red
            width: parseStyleDoubleValue(matches[0]),
            style: matches[1],
            color: parseStyleColor(matches[2])
        };
        default: return {};
    }
}
exports.parseBorderStyle = parseBorderStyle;
function parseStyleDoubleValue(value) {
    // return `(${value}).toDouble()` // used to be necessary, but fixed in Dart 2.0
    return value;
}
exports.parseStyleDoubleValue = parseStyleDoubleValue;
/**
 * Fallback double value parser, in case the result must be a constant value
 * or else the dart compiler will complain.
 * @param value the value to process
 */
function parseConstStyleDoubleValue(value) {
    if (parseFloat(value) || value == '0')
        return parseFloat(value).toFixed(2).toString();
    return value;
}
exports.parseConstStyleDoubleValue = parseConstStyleDoubleValue;
function parseStyleUrl(value) {
    const matchesUrl = /url\(['"]([a-zA-Z0-9:\/\._-]+)['"]\)/g.exec(value);
    if (matchesUrl)
        return {
            type: 'url',
            location: matchesUrl[1]
        };
    const matchesAsset = /asset\(['"]([a-zA-Z0-9:\/\._-]+)['"]\)/g.exec(value);
    if (matchesAsset)
        return {
            type: 'asset',
            location: matchesAsset[1]
        };
    return null;
}
exports.parseStyleUrl = parseStyleUrl;
function parseBoxShadow(value) {
    const regexp = /([\w\.\(\)\:\_\-\#\[\]]+)/g;
    const matches = value.match(regexp);
    let params = [];
    switch (matches.length) {
        case 2: {
            return {
                hoffset: parseConstStyleDoubleValue(matches[0]),
                voffset: parseConstStyleDoubleValue(matches[1])
            };
        }
        case 3: {
            if (parseStyleColor(matches[2]) == matches[2]) {
                return {
                    hoffset: parseConstStyleDoubleValue(matches[0]),
                    voffset: parseConstStyleDoubleValue(matches[1]),
                    color: parseStyleColor(matches[3])
                };
            }
            else {
                return {
                    hoffset: parseConstStyleDoubleValue(matches[0]),
                    voffset: parseConstStyleDoubleValue(matches[1]),
                    blur: parseConstStyleDoubleValue(matches[2])
                };
            }
        }
        case 4: {
            if (parseStyleColor(matches[3]) == matches[3]) {
                return {
                    hoffset: parseConstStyleDoubleValue(matches[0]),
                    voffset: parseConstStyleDoubleValue(matches[1]),
                    blur: parseConstStyleDoubleValue(matches[2]),
                    color: parseStyleColor(matches[3])
                };
            }
            else {
                return {
                    hoffset: parseConstStyleDoubleValue(matches[0]),
                    voffset: parseConstStyleDoubleValue(matches[1]),
                    blur: parseConstStyleDoubleValue(matches[2]),
                    spread: parseConstStyleDoubleValue(matches[3])
                };
            }
        }
        case 5: {
            return {
                hoffset: parseConstStyleDoubleValue(matches[0]),
                voffset: parseConstStyleDoubleValue(matches[1]),
                blur: parseConstStyleDoubleValue(matches[2]),
                spread: parseConstStyleDoubleValue(matches[3]),
                color: parseStyleColor(matches[4])
            };
        }
        default: throw `box-shadow style ${value} is invalid, needs at least hoffset and voffset, but found ${matches.length} properties.`;
    }
}
exports.parseBoxShadow = parseBoxShadow;
/**
 * Recursively apply all plugins to the widget and its descendants, either modifying or creating a new widget tree
 * @param widget the widget to apply all passed plugins on
 * @param plugins the plugins to apply
 */
function applyPlugins(widget, plugins, options) {
    if (!plugins || plugins.length == 0)
        return widget;
    const plugin = plugins[0];
    const newWidget = plugin.transformWidget(widget, options);
    return applyPlugins(newWidget, lodash_1.tail(plugins), options);
}
exports.applyPlugins = applyPlugins;
/**
 * Apply a widget transformation function on a widget
 * @param widget the widget whose parameters to apply the transformation function on
 * @param fn takes a widget and returns a modified or new widget, that should replace the value in the parameter
 */
function applyOnDescendants(widget, fn) {
    if (!widget.params)
        return;
    for (let param of widget.params) {
        switch (param.type) {
            case 'array':
            case 'widgets': {
                const widgets = param.value;
                param.value = widgets.map(fn);
            }
            case 'widget': {
                const widget = param.value;
                param.value = fn(widget);
            }
        }
    }
}
exports.applyOnDescendants = applyOnDescendants;
/**
 * Gets the first child from either the child or the children property
 * @param widget the widget to get the child from
 * @returns a widget if it a child was found, or null if nothing was found
 */
function getWidgetChildren(widget) {
    if (!widget.params)
        return [];
    const childParam = widget.params.find(param => param.name == 'child' && param.type == 'widget' && !!param.value);
    const childrenParam = widget.params.find(param => param.name == 'children' && param.type == 'widgets' && !!param.value);
    if (childParam)
        return [childParam.value];
    if (childrenParam)
        return childrenParam.value;
    return [];
}
exports.getWidgetChildren = getWidgetChildren;
function toBorderRadiusCode(radiusParam) {
    function toRadius(value) {
        if (parseFloat(value) || parseFloat(value) == 0) {
            return `Radius.circular(${parseStyleDoubleValue(value)})`;
        }
        else {
            return unquote(value);
        }
    }
    const radius = radiusParam.value.toString();
    if (radiusParam.type == 'expression')
        return radius;
    const radiusValue = parseTRBLStyle(radius);
    const params = [];
    if (radiusValue.top)
        params.push(`topLeft: ${toRadius(radiusValue.top)}`);
    if (radiusValue.right)
        params.push(`topRight: ${toRadius(radiusValue.right)}`);
    if (radiusValue.bottom)
        params.push(`bottomRight: ${toRadius(radiusValue.bottom)}`);
    if (radiusValue.left)
        params.push(`bottomLeft: ${toRadius(radiusValue.left)}`);
    return `BorderRadius.only(${params.join(', ')})`;
}
exports.toBorderRadiusCode = toBorderRadiusCode;

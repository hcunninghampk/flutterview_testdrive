"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const lodash_1 = require("lodash");
const tools_1 = require("../tools");
/**
 * Processes text styles on a container, and if any styles are found, it wraps the container
 * with a DefaultTextStyle wrapper widget, which applies those styles on the container and
 * its descendants.
 */
function transformWidget(widget, options) {
    if (widget.name != 'Container' && widget.name != 'AnimatedContainer' && widget.name != 'TextSpan') {
        tools_1.applyOnDescendants(widget, descendant => transformWidget(descendant, options));
        return widget;
    }
    const fontSizeParam = tools_1.findAndRemoveParam(widget, 'fontSize');
    const fontColorParam = tools_1.findAndRemoveParam(widget, 'color');
    const fontFamilyParam = tools_1.findAndRemoveParam(widget, 'fontFamily');
    const fontWeightParam = tools_1.findAndRemoveParam(widget, 'fontWeight');
    const fontStyleParam = tools_1.findAndRemoveParam(widget, 'fontStyle');
    const lineHeightParam = tools_1.findAndRemoveParam(widget, 'lineHeight');
    const letterSpacingParam = tools_1.findAndRemoveParam(widget, 'letterSpacing');
    const textDecorationParam = tools_1.findAndRemoveParam(widget, 'textDecoration');
    const textDecorationColorParam = tools_1.findAndRemoveParam(widget, 'textDecorationColor');
    const textDecorationStyleParam = tools_1.findAndRemoveParam(widget, 'textDecorationStyle');
    const wordSpacingParam = tools_1.findAndRemoveParam(widget, 'wordSpacing');
    const textAlignParam = tools_1.findAndRemoveParam(widget, 'textAlign');
    const textOverflowParam = tools_1.findAndRemoveParam(widget, 'textOverflow');
    const wordWrapParam = tools_1.findAndRemoveParam(widget, 'wordWrap');
    const softWrapParam = tools_1.findAndRemoveParam(widget, 'softWrap');
    const maxLinesParam = tools_1.findAndRemoveParam(widget, 'maxLines');
    const lineClampParam = tools_1.findAndRemoveParam(widget, 'lineClamp');
    const update = fontSizeParam ||
        fontColorParam ||
        fontFamilyParam ||
        fontWeightParam ||
        fontStyleParam ||
        lineHeightParam ||
        textDecorationParam ||
        textDecorationColorParam ||
        textDecorationStyleParam ||
        letterSpacingParam ||
        wordSpacingParam ||
        textAlignParam ||
        textOverflowParam ||
        wordWrapParam ||
        softWrapParam ||
        maxLinesParam ||
        lineClampParam;
    if (!update) {
        tools_1.applyOnDescendants(widget, descendant => transformWidget(descendant, options));
        return widget;
    }
    const textStyleParams = [];
    if (fontSizeParam) {
        textStyleParams.push({
            class: 'param',
            name: 'fontSize',
            type: 'expression',
            value: tools_1.parseStyleDoubleValue(fontSizeParam.value.toString()),
            resolved: true
        });
    }
    if (fontColorParam) {
        textStyleParams.push({
            class: 'param',
            name: 'color',
            type: 'expression',
            value: tools_1.parseStyleColor(tools_1.unquote(fontColorParam.value.toString())),
            resolved: true
        });
    }
    if (fontFamilyParam) {
        textStyleParams.push({
            class: 'param',
            name: 'fontFamily',
            type: 'expression',
            value: tools_1.parseStyleString(fontFamilyParam),
            resolved: true
        });
    }
    if (fontWeightParam) {
        let value = tools_1.unquote(fontWeightParam.value.toString());
        if (fontWeightParam.type == 'literal') {
            const fontWeightProperty = parseInt(value) ? 'w' + value : value;
            value = `FontWeight.${fontWeightProperty}`;
        }
        textStyleParams.push({
            class: 'param',
            name: 'fontWeight',
            type: 'expression',
            value: value,
            resolved: true
        });
    }
    if (fontStyleParam) {
        textStyleParams.push({
            class: 'param',
            name: 'fontStyle',
            type: 'expression',
            value: tools_1.parsePropertyStyle('FontStyle', fontStyleParam),
            resolved: true
        });
    }
    if (lineHeightParam) {
        textStyleParams.push({
            class: 'param',
            name: 'height',
            type: 'expression',
            value: tools_1.parseStyleDoubleValue(lineHeightParam.value.toString()),
            resolved: true
        });
    }
    if (letterSpacingParam) {
        textStyleParams.push({
            class: 'param',
            name: 'letterSpacing',
            type: 'expression',
            value: tools_1.parseStyleDoubleValue(letterSpacingParam.value.toString()),
            resolved: true
        });
    }
    if (textDecorationParam) {
        textStyleParams.push({
            class: 'param',
            name: 'decoration',
            type: 'expression',
            value: tools_1.parsePropertyStyle('TextDecoration', textDecorationParam),
            resolved: true
        });
    }
    if (textDecorationColorParam) {
        textStyleParams.push({
            class: 'param',
            name: 'decorationColor',
            type: 'expression',
            value: tools_1.parseStyleColor(tools_1.unquote(textDecorationColorParam.value.toString())),
            resolved: true
        });
    }
    if (textDecorationStyleParam) {
        textStyleParams.push({
            class: 'param',
            name: 'decorationStyle',
            type: 'expression',
            value: tools_1.parsePropertyStyle('TextDecorationStyle', textDecorationStyleParam),
            resolved: true
        });
    }
    if (wordSpacingParam) {
        textStyleParams.push({
            class: 'param',
            name: 'wordSpacing',
            type: 'expression',
            value: tools_1.parseStyleDoubleValue(wordSpacingParam.value.toString()),
            resolved: true
        });
    }
    // create the DefaultTextStyle wrapper
    const params = [
        {
            class: 'param',
            name: 'child',
            type: 'widget',
            value: transformWidget(widget, options),
            resolved: true
        }
    ];
    if (textStyleParams.length > 0)
        params.push({
            class: 'param',
            name: 'style',
            type: 'widget',
            value: {
                constant: false,
                class: 'widget',
                name: 'TextStyle',
                params: textStyleParams
            },
            resolved: true
        });
    if (textAlignParam) {
        params.push({
            class: 'param',
            name: 'textAlign',
            type: 'expression',
            value: tools_1.parsePropertyStyle('TextAlign', textAlignParam),
            resolved: true
        });
    }
    if (textOverflowParam) {
        params.push({
            class: 'param',
            name: 'overflow',
            type: 'expression',
            value: tools_1.parsePropertyStyle('TextOverflow', textOverflowParam),
            resolved: true
        });
    }
    if (wordWrapParam || softWrapParam) {
        let wordWrap;
        if (softWrapParam) {
            wordWrap = softWrapParam.value.toString();
        }
        else {
            switch (tools_1.unquote(wordWrapParam.value.toString())) {
                case 'normal':
                case 'true': {
                    wordWrap = 'true';
                    break;
                }
                case 'break-word':
                case 'false': {
                    wordWrap = 'false';
                    break;
                }
                default: {
                    console.log('no valid word-wrap style set, expecting one of [true, false, normal, break-word].');
                }
            }
        }
        params.push({
            class: 'param',
            name: 'softWrap',
            type: 'expression',
            value: wordWrap,
            resolved: true
        });
    }
    if (maxLinesParam || lineClampParam) {
        let maxLinesValue;
        if (maxLinesParam)
            maxLinesValue = maxLinesParam.value.toString();
        if (lineClampParam)
            maxLinesValue = lineClampParam.value.toString();
        params.push({
            class: 'param',
            name: 'maxLines',
            type: 'expression',
            value: tools_1.unquote(maxLinesValue),
            resolved: true
        });
    }
    // if the widget uses for, move that for to the textstyle instead
    const forParam = tools_1.findParam(widget, 'for');
    if (forParam) {
        lodash_1.pull(widget.params, forParam);
        params.push(forParam);
    }
    if (widget.name == 'Container' || widget.name == 'AnimatedContainer') {
        const newRootWidget = {
            constant: false,
            class: 'widget',
            name: 'DefaultTextStyle.merge',
            params: params
        };
        tools_1.applyOnDescendants(newRootWidget, descendant => transformWidget(descendant, options));
        return newRootWidget;
    }
    else {
        console.log('processing!', widget);
        if (!widget.params)
            widget.params = [];
        // widget.params.push({
        // 	class: 'param',
        // 	name: 'style',
        // 	type: 'widget',
        // 	resolved: true,
        // 	value: {
        // 		constant: false,
        // 		class: 'widget',
        // 		name: 'TextStyle',
        // 		params: params
        // 	}
        // })
        tools_1.applyOnDescendants(widget, descendant => transformWidget(descendant, options));
        return widget;
    }
}
exports.transformWidget = transformWidget;

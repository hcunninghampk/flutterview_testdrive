"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const change_case_1 = require("change-case");
const decode = require("decode-html");
const lodash_1 = require("lodash");
/**
 * Extracts from the html any import elements, and returns those elements as imports
 * @param html the html elements, which get modified
 * @returns a list of import urls
 */
function extractImports(html) {
    const imports = [];
    for (const el of html) {
        if (el.type == 'tag') {
            const tag = el;
            if (tag.name == 'import') {
                imports.push(tag);
            }
        }
    }
    for (let tag of imports) {
        lodash_1.pull(html, tag);
    }
    const packageImports = imports
        .map(i => i.attribs['package'])
        .filter(i => !!i)
        .map(i => `package:${i}`);
    const fileImports = imports
        .map(i => i.attribs['file'])
        .filter(i => !!i);
    return lodash_1.concat(packageImports, fileImports);
}
exports.extractImports = extractImports;
/**
 * Compiles a parsed html tree into Flutter Dart code
 * @param html parsed html elements
 * @param options compilation options
 * @returns generated Dart widget tree
 */
function compile(html, options) {
    return html
        // .filter(el=>isFlutterView(el))
        .map(el => compileTag(el, options));
}
exports.compile = compile;
/**
 * Converts a tag and all of its children into a flutter dart tree
 * @param tag the tag and children to convert
 * @param options compilation options
 * @returns widget descriptor with tree of connected children widgets
 */
function compileTag(tag, options) {
    // use the configured class name if we set it in the tagClasses option
    const originalName = tag.name;
    for (let tagName of Object.keys(options.tagClasses)) {
        if (tag.name == tagName)
            tag.name = options.tagClasses[tagName];
    }
    // start building a widget with params
    const widgetClass = change_case_1.upperCaseFirst(change_case_1.camelCase(tag.name));
    const params = [];
    let generics;
    let pugLine;
    let pugColumn;
    // process the tag attributes, transforming them into widget params
    if (tag.attribs) {
        for (const attr in tag.attribs) {
            let type;
            let name;
            if (attr.startsWith(':')) {
                type = 'expression';
                name = attr.substring(1);
            }
            else if (attr.startsWith('@')) {
                type = 'closure';
                name = attr.substring(1);
            }
            else {
                type = 'literal';
                name = attr;
            }
            let value = tag.attribs[attr];
            if (value && value.startsWith(':')) {
                type = 'expression';
                value = value.substring(1);
            }
            switch (attr) {
                case 'pug-line': {
                    const tagValue = tag.attribs[attr];
                    const parts = tagValue.split(',');
                    pugLine = parseInt(parts[0]);
                    pugColumn = parseInt(parts[1]);
                    break;
                }
                case 'type': {
                    generics = value
                        .split(',')
                        .map(param => param.trim());
                    break;
                }
                default: {
                    const resolved = name.startsWith('^');
                    params.push({
                        class: 'param',
                        type: type,
                        name: (name == 'value' && !resolved) ? undefined : change_case_1.camelCase(name),
                        originalName: name,
                        value: attr != value ? decode(value) : true,
                        resolved: resolved
                    });
                }
            }
        }
    }
    // process the tag children, transforming them into a widget param named 'children'
    if (tag.children) {
        const children = [];
        for (const child of tag.children) {
            switch (child.type) {
                case 'tag': {
                    const subTag = child;
                    const widget = compileTag(subTag, options);
                    children.push(widget);
                    break;
                }
                case 'text': {
                    const text = child;
                    const values = text.data.split('\n').map(line => line.trim());
                    for (let value of values) {
                        if (value.length !== 0 && !value.startsWith('//')) {
                            const widget = {
                                class: 'widget',
                                name: options.tagClasses['text'],
                                originalName: 'text',
                                constant: false,
                                params: [
                                    {
                                        class: 'param',
                                        type: 'literal',
                                        // value: escapeQuotes(decode(value)),
                                        value: decode(value),
                                        resolved: true
                                    }
                                ]
                            };
                            children.push(widget);
                        }
                    }
                }
            }
        }
        // always add children as the children property
        if (children.length > 0) {
            params.push({
                class: 'param',
                type: 'widgets',
                name: 'children',
                value: children,
                resolved: true
            });
        }
    }
    // create the widget for the tag using the name and parameters
    const isConstant = tag.attribs && (tag.attribs['const'] || tag.attribs['const'] == '');
    return {
        class: 'widget',
        constant: isConstant,
        name: widgetClass,
        originalName,
        generics,
        params,
        pugLine,
        pugColumn
    };
}
